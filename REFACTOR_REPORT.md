# Отчет о рефакторинге проекта "Интернет-магазин"

Изначально проект представлял собой приложение с тесно связанной архитектурой: один компонент (`App.jsx`) содержал большую часть логики, все стили описывались в глобальном файле `App.css`, а состояние управлялось монолитным Redux-хранилищем. Такая структура затрудняет поддержку и масштабирование.

Основная цель рефакторинга —> внедрение принципа разделения ответственности. Я разделила приложение на логические, независимые и переиспользуемые модули, что является ключевой практикой в современной веб-разработке.

## Ключевые изменения и их обоснование

### 1. Разделение на компоненты и модули

*   **Декомпозиция компонентов:** Монолитный `App.jsx` был разбит на мелкие, сфокусированные компоненты (`Header`, `ProductList`, `Cart`), которые были вынесены в отдельную директорию `src/components`.
*   **Создание компонента `CartItem`:** Для дальнейшей оптимизации и инкапсуляции логики был создан компонент `CartItem.jsx`, отвечающий за отображение одного товара в корзине.
*   **Изоляция API-логики:** Логика, имитирующая запросы к серверу, была вынесена в директорию `src/api` и разделена на `mockData.js` (хранение данных) и `mockApi.js` (функции для получения этих данных).

**Почему это важно:** Компоненты-гиганты = антипаттерн. Разделение на модули позволяет упростить поддержку, повысить переиспользуемость и изолировать логику.

### 2. Реструктуризация управления состоянием

*   Монолитный `appSlice` разделила на четыре слайса, каждый из которых отвечает за свою доменную область: `cartSlice`, `productSlice`, `userSlice` и `statusSlice`.
*   В `cartSlice` была устранена избыточность: удалила производные поля состояния, а логика подсчета итогов вынесена в переиспользуемую функцию.

**Почему это важно:** Разделение состояния по доменам делает его предсказуемым и модульным. Теперь логика, связанная с корзиной, полностью инкапсулирована в `cartSlice`, что упрощает ее тестирование и расширение.

### 3. Централизация конфигурации и ресурсов

*   **Интернационализация (i18n):** Все текстовые строки были вынесены из компонентов в единый файл `src/locales/ru.json`.
*   **Настройка точки входа:** Глобальный `Provider` Redux и импорт стилей были перенесены из `App.jsx` в корневой файл `main.jsx`.

**Почему это важно:** Такой подход упрощает управление контентом (включая будущие переводы) и создает чистую архитектуру, где точка входа `main.jsx` отвечает за настройку окружения.

### 4. Оптимизация производительности и стиля кода

*   **Единообразие стиля:** Все компоненты были переписаны с использованием синтаксиса стрелочных функций (`const Component = () => {}`).
*   **Мемоизация:** Для оптимизации производительности были применены хуки `useMemo` (для сложных вычислений), `useCallback` (для функций-обработчиков) и `React.memo` (для компонентов в списках, как `CartItem`).

**Почему это важно:** Единый стиль делает код более предсказуемым. Мемоизация предотвращает лишние вычисления и перерисовки компонентов, что важно для производительности списков и сложных интерфейсов.

## Итог

В результате рефакторинга сделала переход от хрупкой монолитной структуры к гибкой, модульной архитектуре, соответствующей современным стандартам разработки. Код стал более читаемым, производительным и готовым к дальнейшему масштабированию и поддержке. Каждый модуль теперь имеет четкую и единственную зону ответственности.

## Предложения по дальнейшему развитию

1.  Перенос асинхронной логики в Redux** с помощью `createAsyncThunk`.
2.  Внедрение роутинга** с `react-router-dom` для создания многостраничного приложения.
3.  Завершение перехода на модульную стилизацию**.
4.  Постепенная миграция на TypeScript** для повышения надежности кода.
5.  Приложения не должны зависеть от внешних бесплатных сервисов, которые не контролируеются. Сервис via.placeholder может быть заблокирован или временно недоступен. В результате пользователь видит сломанное приложение. Самое надежное хранить статические ресурсы (ассеты), такие как изображения, внутри самого проекта.